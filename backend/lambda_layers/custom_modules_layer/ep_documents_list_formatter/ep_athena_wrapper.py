import time
from typing import Optional, Dict
import logging
import boto3
import botocore.exceptions

logger = logging.getLogger(__name__)

class EpAthenaThinWrapper:

    def __init__(
        self,
        session=None,
        database="athenadb",
        region_name="eu-central-1",
        s3_bucket="ep-archives-archibot",
        temporary_files_folder="athena",
        default_repeat=12,
        default_interval=5
    ):
        if session is None:
            session = boto3.Session(region_name=region_name)

        self.session = session
        self.athena_client = session.client("athena")
        self.database = database
        self.s3_client = session.client("s3")
        self.s3_bucket = s3_bucket
        self.aws_region = region_name
        self.temporary_files_folder = temporary_files_folder
        self.default_repeat = default_repeat
        self.default_interval = default_interval
        print(f"Thin Athena wrapper successfully inizialized: {self}")

    def execute_query(self, sql: str, repeat=None, interval=None) -> Optional[Dict]:
        """
        Executes a SQL query and waits for the result.
        Returns up to 1000 rows (default limit from Athena).
        """
        repeat = repeat or self.default_repeat
        interval = interval or self.default_interval

        execution_id = self.__get_query_execution_id(sql)
        if not execution_id:
            return None

        state = self.__wait_for_query_completion(execution_id, repeat, interval)
        if state == "SUCCEEDED":
            return self.__get_query_results(execution_id)

        logger.error(f"Query {execution_id} did not succeed. Final state: {state}")
        return None

    def __wait_for_query_completion(self, execution_id: str, repeat, interval) -> Optional[str]:
        """
        Polls the query execution state until it completes or times out.
        """
        state = "RUNNING"
        try:
            while repeat > 0 and state in ["RUNNING", "QUEUED"]:
                repeat -= 1
                response = self.athena_client.get_query_execution(QueryExecutionId=execution_id)
                state = response.get("QueryExecution", {}).get("Status", {}).get("State", "UNKNOWN")
                logger.debug(f"state={state}, counter={repeat}")

                if state == "SUCCEEDED":
                    return state
                if state == "FAILED":
                    logger.error(f"Query {execution_id} failed.")
                    return None

                time.sleep(interval)

        except self.athena_client.exceptions.InvalidRequestException as e:
            logger.error(f'InvalidRequestException while executing query {execution_id}: {e}')
        except Exception as e:
            logger.error(f'Unexpected error while executing query {execution_id}: {e}')

        return None

    def __get_query_execution_id(self, sql: str) -> Optional[str]:
        try:
            response = self.athena_client.start_query_execution(
                QueryString=sql,
                QueryExecutionContext={"Database": self.database},
                ResultConfiguration={
                    "OutputLocation": f"s3://{self.s3_bucket}/{self.temporary_files_folder}/",
                },
            )
            execution_id = response["QueryExecutionId"]
            logger.info(f"Execution started with id={execution_id}")
            return execution_id

        except self.athena_client.exceptions.InvalidRequestException as e:
            logger.error(f"InvalidRequestException starting query: {e}")
        except self.athena_client.exceptions.InternalServerException as e:
            logger.error(f"InternalServerException starting query: {e}")
        except Exception as e:
            logger.error(f"Unexpected error starting query: {e}")

        return None

    def __get_query_results(self, execution_id: str) -> dict:
        logger.debug(f"Retrieving results for execution_id={execution_id}")
        try:
            response = self.athena_client.get_query_results(QueryExecutionId=execution_id)
            logger.info("Query successfully completed.")
            return response
        finally:
            self.__clean_query_temporary_files(execution_id)

    def __clean_query_temporary_files(self, execution_id: str):
        """
        Deletes the temporary CSV and metadata files generated by Athena.
        """
        csv_key = f"{self.temporary_files_folder}/{execution_id}.csv"
        meta_key = f"{csv_key}.metadata"

        self.__delete_s3_object(csv_key)
        self.__delete_s3_object(meta_key)
        logger.info(f"Deleted temporary files for execution_id={execution_id}")

    def __delete_s3_object(self, obj_key: str) -> Optional[int]:
        """
        Deletes the specified S3 object if it exists.
        """
        try:
            self.s3_client.head_object(Bucket=self.s3_bucket, Key=obj_key)
        except botocore.exceptions.ClientError as e:
            if e.response["Error"]["Code"] == "404":
                logger.debug(f"S3 object not found: {obj_key}")
                return 404
            logger.error(f"Error checking object {obj_key}: {e}")
            return None

        try:
            response = self.s3_client.delete_object(Bucket=self.s3_bucket, Key=obj_key)
            return response.get("ResponseMetadata", {}).get("HTTPStatusCode", None)
        except Exception as e:
            logger.error(f"Error deleting object {obj_key}: {e}")
            return None
